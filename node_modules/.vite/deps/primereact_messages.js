"use client";
import {
  CSSTransition,
  CheckIcon,
  ExclamationTriangleIcon,
  InfoCircleIcon,
  TimesCircleIcon,
  TimesIcon,
  TransitionGroup_default
} from "./chunk-65LZWXBE.js";
import {
  ComponentBase,
  Ripple,
  useHandleStyle
} from "./chunk-BE7P3D3R.js";
import {
  IconUtils,
  ObjectUtils,
  PrimeReactContext,
  ariaLabel,
  classNames,
  useMergeProps,
  useTimeout
} from "./chunk-FMTLT4GF.js";
import "./chunk-HOIQ4OQT.js";
import {
  require_react
} from "./chunk-MZWF525E.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/primereact/messages/messages.esm.js
var React = __toESM(require_react());
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
var styles = "\n@layer primereact {\n    .p-message-wrapper {\n        display: flex;\n        align-items: center;\n    }\n\n    .p-message-icon {\n        flex-shrink: 0;\n    }\n    \n    .p-message-close {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n    \n    .p-message-close.p-link {\n        margin-left: auto;\n        overflow: hidden;\n        position: relative;\n    }\n    \n    .p-message-enter {\n        opacity: 0;\n    }\n    \n    .p-message-enter-active {\n        opacity: 1;\n        transition: opacity .3s;\n    }\n    \n    .p-message-exit {\n        opacity: 1;\n        max-height: 1000px;\n    }\n    \n    .p-message-exit-active {\n        opacity: 0;\n        max-height: 0;\n        margin: 0;\n        overflow: hidden;\n        transition: max-height .3s cubic-bezier(0, 1, 0, 1), opacity .3s, margin .3s;\n    }\n    \n    .p-message-exit-active .p-message-close {\n        display: none;\n    }\n}\n";
var classes = {
  uimessage: {
    root: function root(_ref) {
      var severity = _ref.severity;
      return classNames("p-message p-component", _defineProperty({}, "p-message-".concat(severity), severity));
    },
    wrapper: "p-message-wrapper",
    detail: "p-message-detail",
    summary: "p-message-summary",
    icon: "p-message-icon",
    buttonicon: "p-message-close-icon",
    button: "p-message-close p-link",
    transition: "p-message"
  }
};
var MessagesBase = ComponentBase.extend({
  defaultProps: {
    __TYPE: "Messages",
    __parentMetadata: null,
    id: null,
    className: null,
    style: null,
    transitionOptions: null,
    onRemove: null,
    onClick: null,
    children: void 0
  },
  css: {
    classes,
    styles
  }
});
function ownKeys$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var UIMessage = React.memo(React.forwardRef(function(props, ref) {
  var mergeProps = useMergeProps();
  var messageInfo = props.message, parentMetaData = props.metaData, _props$ptCallbacks = props.ptCallbacks, ptm = _props$ptCallbacks.ptm, ptmo = _props$ptCallbacks.ptmo, cx = _props$ptCallbacks.cx, index = props.index;
  var _messageInfo$message = messageInfo.message, severity = _messageInfo$message.severity, content = _messageInfo$message.content, summary = _messageInfo$message.summary, detail = _messageInfo$message.detail, closable = _messageInfo$message.closable, life = _messageInfo$message.life, sticky = _messageInfo$message.sticky, _className = _messageInfo$message.className, style = _messageInfo$message.style, _contentClassName = _messageInfo$message.contentClassName, contentStyle = _messageInfo$message.contentStyle, _icon = _messageInfo$message.icon, _closeIcon = _messageInfo$message.closeIcon, pt = _messageInfo$message.pt;
  var params = {
    index
  };
  var parentParams = _objectSpread$1(_objectSpread$1({}, parentMetaData), params);
  var _useTimeout = useTimeout(function() {
    onClose(null);
  }, life || 3e3, !sticky), _useTimeout2 = _slicedToArray(_useTimeout, 1), clearTimer = _useTimeout2[0];
  var getPTOptions = function getPTOptions2(key, options) {
    return ptm(key, _objectSpread$1({
      hostName: props.hostName
    }, options));
  };
  var onClose = function onClose2(event) {
    clearTimer();
    props.onClose && props.onClose(props.message);
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
  var onClick = function onClick2() {
    props.onClick && props.onClick(props.message);
  };
  var createCloseIcon = function createCloseIcon2() {
    if (closable !== false) {
      var buttonIconProps = mergeProps({
        className: cx("uimessage.buttonicon")
      }, getPTOptions("buttonicon", parentParams), ptmo(pt, "buttonicon", _objectSpread$1(_objectSpread$1({}, params), {}, {
        hostName: props.hostName
      })));
      var icon = _closeIcon || React.createElement(TimesIcon, buttonIconProps);
      var _closeIcon2 = IconUtils.getJSXIcon(icon, _objectSpread$1({}, buttonIconProps), {
        props
      });
      var buttonProps = mergeProps({
        type: "button",
        className: cx("uimessage.button"),
        "aria-label": ariaLabel("close"),
        onClick: onClose
      }, getPTOptions("button", parentParams), ptmo(pt, "button", _objectSpread$1(_objectSpread$1({}, params), {}, {
        hostName: props.hostName
      })));
      return React.createElement("button", buttonProps, _closeIcon2, React.createElement(Ripple, null));
    }
    return null;
  };
  var createMessage = function createMessage2() {
    if (props.message) {
      var iconProps = mergeProps({
        className: cx("uimessage.icon")
      }, getPTOptions("icon", parentParams), ptmo(pt, "icon", _objectSpread$1(_objectSpread$1({}, params), {}, {
        hostName: props.hostName
      })));
      var icon = _icon;
      if (!_icon) {
        switch (severity) {
          case "info":
            icon = React.createElement(InfoCircleIcon, iconProps);
            break;
          case "warn":
            icon = React.createElement(ExclamationTriangleIcon, iconProps);
            break;
          case "error":
            icon = React.createElement(TimesCircleIcon, iconProps);
            break;
          case "success":
            icon = React.createElement(CheckIcon, iconProps);
            break;
        }
      }
      var iconContent = IconUtils.getJSXIcon(icon, _objectSpread$1({}, iconProps), {
        props
      });
      var summaryProps = mergeProps({
        className: cx("uimessage.summary")
      }, getPTOptions("summary", parentParams), ptmo(pt, "summary", _objectSpread$1(_objectSpread$1({}, params), {}, {
        hostName: props.hostName
      })));
      var detailProps = mergeProps({
        className: cx("uimessage.detail")
      }, getPTOptions("detail", parentParams), ptmo(pt, "detail", _objectSpread$1(_objectSpread$1({}, params), {}, {
        hostName: props.hostName
      })));
      return content || React.createElement(React.Fragment, null, iconContent, React.createElement("span", summaryProps, summary), React.createElement("span", detailProps, detail));
    }
    return null;
  };
  var closeIcon = createCloseIcon();
  var message = createMessage();
  var wrapperProps = mergeProps({
    className: classNames(_contentClassName, cx("uimessage.wrapper")),
    style: contentStyle
  }, getPTOptions("wrapper", parentParams), ptmo(pt, "wrapper", _objectSpread$1(_objectSpread$1({}, params), {}, {
    hostName: props.hostName
  })));
  var rootProps = mergeProps({
    ref,
    className: classNames(_className, cx("uimessage.root", {
      severity
    })),
    style,
    role: "alert",
    "aria-live": "assertive",
    "aria-atomic": "true",
    onClick
  }, getPTOptions("root", parentParams), ptmo(pt, "root", _objectSpread$1(_objectSpread$1({}, params), {}, {
    hostName: props.hostName
  })));
  return React.createElement("div", rootProps, React.createElement("div", wrapperProps, message, closeIcon));
}));
UIMessage.displayName = "UIMessage";
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var messageIdx = 0;
var Messages = React.memo(React.forwardRef(function(inProps, ref) {
  var mergeProps = useMergeProps();
  var context = React.useContext(PrimeReactContext);
  var props = MessagesBase.getProps(inProps, context);
  var _React$useState = React.useState([]), _React$useState2 = _slicedToArray(_React$useState, 2), messagesState = _React$useState2[0], setMessagesState = _React$useState2[1];
  var elementRef = React.useRef(null);
  var metaData = _objectSpread(_objectSpread({
    props
  }, props.__parentMetadata), {}, {
    state: {
      messages: messagesState
    }
  });
  var ptCallbacks = MessagesBase.setMetaData(metaData);
  useHandleStyle(MessagesBase.css.styles, ptCallbacks.isUnstyled, {
    name: "messages"
  });
  var show = function show2(messageInfo) {
    if (messageInfo) {
      setMessagesState(function(prev) {
        return assignIdentifiers(prev, messageInfo, true);
      });
    }
  };
  var assignIdentifiers = function assignIdentifiers2(currentState, messageInfo, copy) {
    var messages;
    if (Array.isArray(messageInfo)) {
      var multipleMessages = messageInfo.reduce(function(acc, message2) {
        acc.push({
          _pId: messageIdx++,
          message: message2
        });
        return acc;
      }, []);
      if (copy) {
        messages = currentState ? [].concat(_toConsumableArray(currentState), _toConsumableArray(multipleMessages)) : multipleMessages;
      } else {
        messages = multipleMessages;
      }
    } else {
      var message = {
        _pId: messageIdx++,
        message: messageInfo
      };
      if (copy) {
        messages = currentState ? [].concat(_toConsumableArray(currentState), [message]) : [message];
      } else {
        messages = [message];
      }
    }
    return messages;
  };
  var clear = function clear2() {
    setMessagesState([]);
  };
  var replace = function replace2(messageInfo) {
    setMessagesState(function(prev) {
      return assignIdentifiers(prev, messageInfo, false);
    });
  };
  var remove = function remove2(messageInfo) {
    var removeMessage = ObjectUtils.isNotEmpty(messageInfo._pId) ? messageInfo._pId : messageInfo.message || messageInfo;
    setMessagesState(function(prev) {
      return prev.filter(function(msg) {
        return msg._pId !== messageInfo._pId && !ObjectUtils.deepEquals(msg.message, removeMessage);
      });
    });
    props.onRemove && props.onRemove(messageInfo.message || removeMessage);
  };
  var onClose = function onClose2(messageInfo) {
    remove(messageInfo);
  };
  React.useImperativeHandle(ref, function() {
    return {
      props,
      show,
      replace,
      remove,
      clear,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  var rootProps = mergeProps({
    id: props.id,
    className: props.className,
    style: props.style
  }, MessagesBase.getOtherProps(props), ptCallbacks.ptm("root"));
  var transitionProps = mergeProps({
    classNames: ptCallbacks.cx("uimessage.transition"),
    unmountOnExit: true,
    timeout: {
      enter: 300,
      exit: 300
    },
    options: props.transitionOptions
  }, ptCallbacks.ptm("transition"));
  return React.createElement("div", _extends({
    ref: elementRef
  }, rootProps), React.createElement(TransitionGroup_default, null, messagesState && messagesState.map(function(message, index) {
    var messageRef = React.createRef();
    return React.createElement(CSSTransition, _extends({
      nodeRef: messageRef,
      key: message._pId
    }, transitionProps), React.createElement(UIMessage, {
      hostName: "Messages",
      ref: messageRef,
      message,
      onClick: props.onClick,
      onClose,
      ptCallbacks,
      metaData,
      index
    }));
  })));
}));
Messages.displayName = "Messages";
export {
  Messages
};
//# sourceMappingURL=primereact_messages.js.map
